#!/usr/bin/perl
#
# Generate combinations of different chord voicings between different
# scale degrees. (Using 'no_partial_closed' parameter to prevent awkward
# 3rds in middle of otherwise open chord.) Example usage:
#
# progressions --mode=minor --key='\key c \minor' --flats \
#    --max-leap=7 --max-root-leap=8   I VI     > minor-I-VI.ly
#
# TODO options to control voice leadings (nix || 5ths or whatnot, avoid
# case where one voice falls to pitch occupied by prior voice, etc).
#
# TODO rename util, or merge with mcp2ly, and move ly conversion into module?
#
# TODO audit various modes for correctness (take data and generate scales from
# them? also see what chord_voc is returning)

use strict;
use warnings;

use File::Basename qw/basename/;
use Getopt::Long qw/GetOptions/;
use List::Util qw/sum/;
use Music::Chord::Positions qw/:all/;
use POSIX qw/floor/;

my (
  @orig_args,       @phrase,        %interval_sets, %params,
  %pitch2note,      %Scale_Degs,    %registers,     $duration,
  $exit_status,     $flats,         $fudge,         $just_one,
  $key,             $leap_root_max, $leap_max,      $ly_lower_voices,
  $ly_upper_voices, $mode,          $transpose,     $use_ties,
);
$exit_status = 0;

$leap_max      = 5;
$leap_root_max = 7;
%params        = (
  allow_transpositions => 0,
  no_partial_closed    => 1,
  voice_count          => 4,
);
%interval_sets = (
  '5th-major' => [ chord_pos( [qw/0 4 7/], %params ) ],
  '5th-minor' => [ chord_pos( [qw/0 3 7/], %params ) ],
  '5th-dim'   => [ chord_pos( [qw/0 3 6/], %params ) ],
  '5th-aug'   => [ chord_pos( [qw/0 4 8/], %params ) ],
);
%Scale_Degs = (
  major => {
    I   => { ps => $interval_sets{'5th-major'}, t => 0 },
    II  => { ps => $interval_sets{'5th-minor'}, t => 2 },
    III => { ps => $interval_sets{'5th-minor'}, t => 4 },
    IV  => { ps => $interval_sets{'5th-major'}, t => 5 },
    V   => { ps => $interval_sets{'5th-major'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-minor'}, t => 9 },
    VII => { ps => $interval_sets{'5th-dim'},   t => 11 },
  },
  minor => {
    I   => { ps => $interval_sets{'5th-minor'}, t => 0 },
    II  => { ps => $interval_sets{'5th-dim'},   t => 2 },
    III => { ps => $interval_sets{'5th-major'}, t => 3 },
    IV  => { ps => $interval_sets{'5th-minor'}, t => 5 },
    V   => { ps => $interval_sets{'5th-minor'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-major'}, t => 8 },
    VII => { ps => $interval_sets{'5th-major'}, t => 10 },
  },
  dorian => {
    I   => { ps => $interval_sets{'5th-minor'}, t => 0 },
    II  => { ps => $interval_sets{'5th-minor'}, t => 2 },
    III => { ps => $interval_sets{'5th-major'}, t => 3 },
    IV  => { ps => $interval_sets{'5th-major'}, t => 5 },
    V   => { ps => $interval_sets{'5th-minor'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-dim'},   t => 9 },
    VII => { ps => $interval_sets{'5th-major'}, t => 10 },
  },
  phrygian => {
    I   => { ps => $interval_sets{'5th-minor'}, t => 0 },
    II  => { ps => $interval_sets{'5th-major'}, t => 1 },
    III => { ps => $interval_sets{'5th-major'}, t => 3 },
    IV  => { ps => $interval_sets{'5th-minor'}, t => 5 },
    V   => { ps => $interval_sets{'5th-dim'},   t => 7 },
    VI  => { ps => $interval_sets{'5th-major'}, t => 8 },
    VII => { ps => $interval_sets{'5th-minor'}, t => 10 },
  },
  lydian => {
    I   => { ps => $interval_sets{'5th-major'}, t => 0 },
    II  => { ps => $interval_sets{'5th-major'}, t => 2 },
    III => { ps => $interval_sets{'5th-minor'}, t => 4 },
    IV  => { ps => $interval_sets{'5th-dim'},   t => 6 },
    V   => { ps => $interval_sets{'5th-major'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-minor'}, t => 9 },
    VII => { ps => $interval_sets{'5th-minor'}, t => 11 },
  },
  mixolydian => {
    I   => { ps => $interval_sets{'5th-major'}, t => 0 },
    II  => { ps => $interval_sets{'5th-minor'}, t => 2 },
    III => { ps => $interval_sets{'5th-dim'},   t => 4 },
    IV  => { ps => $interval_sets{'5th-major'}, t => 5 },
    V   => { ps => $interval_sets{'5th-minor'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-minor'}, t => 9 },
    VII => { ps => $interval_sets{'5th-major'}, t => 10 },
  },
  locrian => {
    I   => { ps => $interval_sets{'5th-dim'},   t => 0 },
    II  => { ps => $interval_sets{'5th-major'}, t => 1 },
    III => { ps => $interval_sets{'5th-minor'}, t => 3 },
    IV  => { ps => $interval_sets{'5th-minor'}, t => 5 },
    V   => { ps => $interval_sets{'5th-major'}, t => 6 },
    VI  => { ps => $interval_sets{'5th-major'}, t => 8 },
    VII => { ps => $interval_sets{'5th-minor'}, t => 10 },
  },
);

$Scale_Degs{'ionain'}  = $Scale_Degs{'major'};
$Scale_Degs{'aeolian'} = $Scale_Degs{'minor'};

%pitch2note =
  qw( 0 c 1 cis 2 d 3 dis 4 e 5 f 6 fis 7 g 8 gis 9 a 10 ais 11 b );
%registers = (
  -3 => ",,,",
  -2 => ",,",
  -1 => ",",
  0  => "",
  1  => "'",
  2  => "''",
  3  => "'''",
  4  => "''''",
  5  => "'''''"
);
$duration        = 4;
$fudge           = 0.5;
$key             = '\\key c \\major';
$ly_lower_voices = $ly_upper_voices = '';
$transpose       = 0;

@orig_args = (
  map { my $s = $_; $s =~ s/\\/\\\\/g; $s =~ s/"/\\"/g; $s } basename($0),
  @ARGV
);
GetOptions(
  'flats'           => \$flats,
  'fudge|f=s'       => \$fudge,
  'just-one'        => \$just_one,
  'key=s'           => \$key,
  'mode=s'          => \$mode,
  'max-leap=s'      => \$leap_max,
  'max-root-leap=s' => \$leap_root_max,
  'param|p=s'       => \%params,
  'ties'            => \$use_ties,
  'transpose|t=s'   => \$transpose,
);
@phrase = @ARGV;

if ( !defined $mode or !@phrase or @phrase < 2 ) {
  print_help();
  exit 64;
}

if ($flats) {
  %pitch2note =
    qw( 0 c 1 des 2 d 3 ees 4 e 5 f 6 ges 7 g 8 aes 9 a 10 bes 11 b );
}

# Get voice lines, convert to lilypond format, figure out what staff the
# voices should be in. TODO messy, really should be templated or part of
# the module.
{
  my ( @iters, @lv, @voices, @uv );
  @iters = (0) x @phrase;

PHRASE:
  while ( $iters[0] <= $#{ $Scale_Degs{$mode}{ $phrase[0] }{'ps'} } ) {
  POTENTIAL:
    while ( $iters[-1] <= $#{ $Scale_Degs{$mode}{ $phrase[-1] }{'ps'} } ) {
      my @chords;
      for my $i ( 0 .. $#iters ) {
        push @chords,
          [ map { $_ + $Scale_Degs{$mode}{ $phrase[$i] }{'t'} }
            @{ $Scale_Degs{$mode}{ $phrase[$i] }{'ps'}[ $iters[$i] ] } ];
        if ( @chords > 1 ) {
          next POTENTIAL unless check_dest( @chords[ -2, -1 ] );
        }
      }
      push @voices, @chords;
      last PHRASE if $just_one;
    } continue {
      $iters[-1]++;
    }

    # Increment counters for chords in middle of phrase if necessary
    for my $i ( reverse 1 .. $#iters ) {
      if ( $iters[$i] > $#{ $Scale_Degs{$mode}{ $phrase[$i] }{'ps'} } ) {
        $iters[ $i - 1 ]++;
        $iters[$i] = 0;
      }
    }
  }

  @voices = chords2voices(@voices);

  for my $voice (@voices) {
    my ( @registers, $mean_reg_num );
    for my $pi ( 0 .. $#$voice ) {
      $voice->[$pi] += $transpose if $transpose;
      my $ly_pitch = $pitch2note{ $voice->[$pi] % scale_deg() };
      my $reg_num  = floor( $voice->[$pi] / scale_deg() );
      push @registers, $reg_num;

      $voice->[$pi] = $ly_pitch . $registers{$reg_num};
      $voice->[ $pi - 1 ] .= '~'
        if $use_ties
          and $voice->[ $pi - 1 ] eq $voice->[$pi]
          and $pi % @phrase != 0;
    }
    my $mean_register = floor( sum(@registers) / @$voice + $fudge );

    $voice->[0] .= $duration;

    my $bar_count = 0;
    if ( $mean_register > 0 ) {
      push @uv, join " ",
        map { $_, ( ++$bar_count % @phrase == 0 ) ? '\\bar "||"' : () }
        @$voice;
    } else {
      push @lv, join " ",
        map { $_, ( ++$bar_count % @phrase == 0 ) ? '\\bar "||"' : () }
        @$voice;
    }
  }

  if (@uv) {
    $ly_upper_voices = "<< {\n" . join( "\n} \\\\ {\n", @uv ) . "\n} >>\n";
  }
  if (@lv) {
    $ly_lower_voices = "<< {\n" . join( "\n} \\\\ {\n", @lv ) . "\n} >>\n";
  }
}

exit lyify();

########################################################################
#
# SUBROUTINES

sub lyify {
  my $Mode = ucfirst $mode;
  print <<"END_TMPL";
\\version "2.12.0"

#(define-markup-list-command (paragraph layout props args) (markup-list?)
 (interpret-markup-list layout props
   (make-justified-lines-markup-list (cons (make-hspace-markup 2) args))))

\\header {
  title    = "@phrase in $Mode"
  subtitle = "Music::Chord::Positions v.$Music::Chord::Positions::VERSION"
  tagline  = ##f
}

upper = {
  \\clef treble
  \\tempo 4=168
  \\cadenzaOn
  $key
  $ly_upper_voices
}

lower = {
  \\clef bass
  \\cadenzaOn
  $key
  $ly_lower_voices
}

\\markuplines { \\paragraph {
"@orig_args"
} }

\\score {
  \\new PianoStaff <<
    \\new Staff = "upper" \\upper
    \\new Staff = "lower" \\lower
  >>
  \\layout { }
  \\midi { }
}

\\markuplines { \\paragraph {
Progressions derived from methods outlined in \\underline "Theory of Harmony" by Schoenberg.
} }
END_TMPL
}

sub check_dest {
  my ( $from, $to ) = @_;
  my %seen;

  return 0 if abs( $to->[0] - $from->[0] ) > $leap_root_max;
  for my $vi ( 1 .. $#$from ) {
    return 0 if abs( $to->[$vi] - $from->[$vi] ) > $leap_max;
  }

  my @intervals;
  for my $p ( 1 .. $#$from ) {
    push @intervals, $from->[$p] - $from->[ $p - 1 ];
  }
  for my $p ( 1 .. $#$to ) {
    push @intervals, $to->[$p] - $to->[ $p - 1 ];
  }
  return 0 if $seen{"@intervals"}++;

  return 1;
}

sub print_help {
  warn <<"END_USAGE";
Usage: $0 [options] --mode=[mode] scale degrees

Generates combinations of progressions for the scale degrees mentioned
in the named mode. Scale degrees use uppercase Roman Numerals e.g. I VI
regardless of mode.

Options:
  mode=s           Mode, such as major, minor, dorian, etc. Required.

  flats            Use flats instead of sharps in output.
  fudge|f=s        Fudge factor for what clef voices end up in.
  key=s            Lilypond key, such as '\\key c \\minor' or whatever.
  max-leap=s       Largest semitone leap a non-root voice can make (5).
  max-root-leap=s  Largest semitone leap the root can make (7).
  param|p=s        Custom voicing parameters, see Music::Chord::Positions.
  ties             Generate ties between shared pitches.
  transpose=s      Value in semitones to transpose output by.

END_USAGE
}

END {
  unless ( close(STDOUT) ) {
    warn "error: problem closing STDOUT: $!\n";
    exit 74;
  }
}
