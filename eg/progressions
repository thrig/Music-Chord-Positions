#!/usr/bin/perl
#
# Generate combinations of different chord voicings between different
# scale degrees. (Using 'no_partial_closed' parameter to prevent awkward
# 3rds in middle of otherwise open chord.) Example usage:
#
# progressions --mode=minor --key='\key c \minor' --flats \
#    --max-leap=7 --max-root-leap=8   I VI     > minor-I-VI.ly
#
# TODO options to control voice leadings (nix || 5ths or whatnot, avoid
# case where one voice falls to pitch occupied by prior voice, etc).
#
# TODO rename util, or merge with mcp2ly, and move ly conversion into module?
#
# TODO audit various modes for correctness (take data and generate scales from
# them? also see what chord_voc is returning)

use strict;
use warnings;

use File::Basename qw/basename/;
use Getopt::Long qw/GetOptions/;
use List::Util qw/sum/;
use Music::Chord::Positions qw/:all/;
use POSIX qw/floor/;

my (
  @orig_args,     @phrase,       %interval_sets,   %params,
  %pitch2note,    %Scale_Degs,   %registers,       $duration,
  $exit_status,   $flats,        $fudge,           $key,
  $leap_root_max, $leap_max,     $ly_lower_voices, $ly_upper_voices,
  $mode,          $phrase_count, $transpose,       $use_ties,
);
$exit_status = 0;

$leap_max      = 5;
$leap_root_max = 7;
%params        = (
  allow_transpositions => 0,
  no_partial_closed    => 1,
  voice_count          => 4,
);
%interval_sets = (
  '5th-major' => [ chord_pos( [qw/0 4 7/], %params ) ],
  '5th-minor' => [ chord_pos( [qw/0 3 7/], %params ) ],
  '5th-dim'   => [ chord_pos( [qw/0 3 6/], %params ) ],
  '5th-aug'   => [ chord_pos( [qw/0 4 8/], %params ) ],
);
%Scale_Degs = (
  major => {
    I   => { ps => $interval_sets{'5th-major'}, t => 0 },
    II  => { ps => $interval_sets{'5th-minor'}, t => 2 },
    III => { ps => $interval_sets{'5th-minor'}, t => 4 },
    IV  => { ps => $interval_sets{'5th-major'}, t => 5 },
    V   => { ps => $interval_sets{'5th-major'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-minor'}, t => 9 },
    VII => { ps => $interval_sets{'5th-dim'},   t => 11 },
  },
  minor => {
    I   => { ps => $interval_sets{'5th-minor'}, t => 0 },
    II  => { ps => $interval_sets{'5th-dim'},   t => 2 },
    III => { ps => $interval_sets{'5th-major'}, t => 3 },
    IV  => { ps => $interval_sets{'5th-minor'}, t => 5 },
    V   => { ps => $interval_sets{'5th-minor'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-major'}, t => 8 },
    VII => { ps => $interval_sets{'5th-major'}, t => 10 },
  },
  dorian => {
    I   => { ps => $interval_sets{'5th-minor'}, t => 0 },
    II  => { ps => $interval_sets{'5th-minor'}, t => 2 },
    III => { ps => $interval_sets{'5th-major'}, t => 3 },
    IV  => { ps => $interval_sets{'5th-major'}, t => 5 },
    V   => { ps => $interval_sets{'5th-minor'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-dim'},   t => 9 },
    VII => { ps => $interval_sets{'5th-major'}, t => 10 },
  },
  phrygian => {
    I   => { ps => $interval_sets{'5th-minor'}, t => 0 },
    II  => { ps => $interval_sets{'5th-major'}, t => 1 },
    III => { ps => $interval_sets{'5th-major'}, t => 3 },
    IV  => { ps => $interval_sets{'5th-minor'}, t => 5 },
    V   => { ps => $interval_sets{'5th-dim'},   t => 7 },
    VI  => { ps => $interval_sets{'5th-major'}, t => 8 },
    VII => { ps => $interval_sets{'5th-minor'}, t => 10 },
  },
  lydian => {
    I   => { ps => $interval_sets{'5th-major'}, t => 0 },
    II  => { ps => $interval_sets{'5th-major'}, t => 2 },
    III => { ps => $interval_sets{'5th-minor'}, t => 4 },
    IV  => { ps => $interval_sets{'5th-dim'},   t => 6 },
    V   => { ps => $interval_sets{'5th-major'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-minor'}, t => 9 },
    VII => { ps => $interval_sets{'5th-minor'}, t => 11 },
  },
  mixolydian => {
    I   => { ps => $interval_sets{'5th-major'}, t => 0 },
    II  => { ps => $interval_sets{'5th-minor'}, t => 2 },
    III => { ps => $interval_sets{'5th-dim'},   t => 4 },
    IV  => { ps => $interval_sets{'5th-major'}, t => 5 },
    V   => { ps => $interval_sets{'5th-minor'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-minor'}, t => 9 },
    VII => { ps => $interval_sets{'5th-major'}, t => 10 },
  },
  locrian => {
    I   => { ps => $interval_sets{'5th-dim'},   t => 0 },
    II  => { ps => $interval_sets{'5th-major'}, t => 1 },
    III => { ps => $interval_sets{'5th-minor'}, t => 3 },
    IV  => { ps => $interval_sets{'5th-minor'}, t => 5 },
    V   => { ps => $interval_sets{'5th-major'}, t => 6 },
    VI  => { ps => $interval_sets{'5th-major'}, t => 8 },
    VII => { ps => $interval_sets{'5th-minor'}, t => 10 },
  },
);

$Scale_Degs{'ionain'}  = $Scale_Degs{'major'};
$Scale_Degs{'aeolian'} = $Scale_Degs{'minor'};

%pitch2note =
  qw( 0 c 1 cis 2 d 3 dis 4 e 5 f 6 fis 7 g 8 gis 9 a 10 ais 11 b );
%registers = (
  -3 => ",,,",
  -2 => ",,",
  -1 => ",",
  0  => "",
  1  => "'",
  2  => "''",
  3  => "'''",
  4  => "''''",
  5  => "'''''"
);
$duration        = 1;
$fudge           = 0.5;
$key             = '\\key c \\major';
$ly_lower_voices = $ly_upper_voices = '';
$transpose       = 0;

@orig_args = (
  map { my $s = $_; $s =~ s/\\/\\\\/g; $s =~ s/"/\\"/g; $s } basename($0),
  @ARGV
);
GetOptions(
  'flats'           => \$flats,
  'fudge|f=s'       => \$fudge,
  'key=s'           => \$key,
  'mode=s'          => \$mode,
  'max-leap=s'      => \$leap_max,
  'max-root-leap=s' => \$leap_root_max,
  'param|p=s'       => \%params,
  'ties'            => \$use_ties,
  'transpose|t=s'   => \$transpose,
);
@phrase = @ARGV;

if ( !defined $mode or !@phrase or @phrase < 2 ) {
  print_help();
  exit 64;
}

if ($flats) {
  %pitch2note =
    qw( 0 c 1 des 2 d 3 ees 4 e 5 f 6 ges 7 g 8 aes 9 a 10 bes 11 b );
}

{
  my ( @iters, @lv, @voices, @uv );
  @iters = (0) x @phrase;

  for my $ps ( @{ $Scale_Degs{$mode}{ $phrase[0] }{'ps'} } ) {
    gen_phrase( 1, [$ps], \@voices );
  }
  die "error: no voicings generated (options too restrictive?)\n" if !@voices;
  warn "info: generated $phrase_count phrases\n";

  @voices = chords2voices(@voices);

  for my $voice (@voices) {
    my ( @registers, $mean_reg_num );
    for my $pi ( 0 .. $#$voice ) {
      $voice->[$pi] += $transpose if $transpose;
      my $ly_pitch = $pitch2note{ $voice->[$pi] % scale_deg() };
      my $reg_num  = floor( $voice->[$pi] / scale_deg() );
      push @registers, $reg_num;

      $voice->[$pi] = $ly_pitch . $registers{$reg_num};
      $voice->[ $pi - 1 ] .= '~'
        if $use_ties
          and $voice->[ $pi - 1 ] eq $voice->[$pi]
          and $pi % @phrase != 0;
    }
    my $mean_register = floor( sum(@registers) / @$voice + $fudge );

    $voice->[0] .= $duration;

    my $bar_count = 0;
    if ( $mean_register > 0 ) {
      push @uv, join " ",
        map { $_, ( ++$bar_count % @phrase == 0 ) ? '\\bar "||"' : () }
        @$voice;
    } else {
      push @lv, join " ",
        map { $_, ( ++$bar_count % @phrase == 0 ) ? '\\bar "||"' : () }
        @$voice;
    }
  }

  if (@uv) {
    $ly_upper_voices = "<< {\n" . join( "\n} \\\\ {\n", @uv ) . "\n} >>\n";
  }
  if (@lv) {
    $ly_lower_voices = "<< {\n" . join( "\n} \\\\ {\n", @lv ) . "\n} >>\n";
  }
}

exit lyify();

########################################################################
#
# SUBROUTINES

# Audit that voices do not leap too far between two chords of a phrase.
# If transpositions allowed in generation, may need to audit for repeated
# interval sets (same chords in different register).
sub check_dest {
  my ( $from, $to ) = @_;
  my %seen;

  return 0 if abs( $to->[0] - $from->[0] ) > $leap_root_max;
  for my $vi ( 1 .. $#$from ) {
    return 0 if abs( $to->[$vi] - $from->[$vi] ) > $leap_max;
  }

  return 1;
}

# This method keeps the voices within a certain range, as all the roots
# are those above and below 0 (transposed as necessary for the scale
# degree), and the voices will only wander as far as the leap settings
# and available chord voicings permit. A different method could be
# devised that would pick new roots around the root of the previous
# chord; this would likely cause the musical line to wander more, as the
# chord voicings could end up in progressively distant registers from 0.
sub gen_phrase {
  my ( $index, $pphrase, $voices ) = @_;

  for my $ps ( @{ $Scale_Degs{$mode}{ $phrase[$index] }{'ps'} } ) {
    for my $offset (
      $Scale_Degs{$mode}{ $phrase[$index] }{'t'},
      -12 + $Scale_Degs{$mode}{ $phrase[$index] }{'t'}
      ) {
      my $potential = [ @$pphrase, [ map { $_ + $offset } @$ps ] ];

      if ( !check_dest( $potential->[-2], $potential->[-1] ) ) {
        next;
      }

      if ( $index < $#phrase ) {
        gen_phrase( $index + 1, $potential, $voices );
      } else {
        push @$voices, @{$potential};
        $phrase_count++;
      }
    }
  }
}

sub lyify {
  my $Mode = ucfirst $mode;
  print <<"END_TMPL";
\\version "2.12.0"

#(define-markup-list-command (paragraph layout props args) (markup-list?)
 (interpret-markup-list layout props
   (make-justified-lines-markup-list (cons (make-hspace-markup 2) args))))

\\header {
  title    = "@phrase in $Mode"
  subtitle = "Music::Chord::Positions v.$Music::Chord::Positions::VERSION"
  tagline  = ##f
}

upper = {
  \\clef treble
  \\tempo 4=168
  \\cadenzaOn
  $key
  $ly_upper_voices
}

lower = {
  \\clef bass
  \\cadenzaOn
  $key
  $ly_lower_voices
}

\\markuplines { \\paragraph {
"@orig_args"
} }

\\score {
  \\new PianoStaff <<
    \\set PianoStaff.midiInstrument = #"Church Organ"
    \\new Staff = "upper" \\upper
    \\new Staff = "lower" \\lower
  >>
  \\layout { }
  \\midi { }
}

\\markuplines { \\paragraph {
Progressions derived from methods outlined in \\underline "Theory of Harmony" by Schoenberg.
} }
END_TMPL
}

sub print_help {
  warn <<"END_USAGE";
Usage: $0 [options] --mode=[mode] scale degrees

Generates combinations of progressions for the scale degrees mentioned
in the named mode. Scale degrees use uppercase Roman Numerals e.g. I VI
regardless of mode.

Options:
  mode=s           Mode, such as major, minor, dorian, etc. Required.

  flats            Use flats instead of sharps in output.
  fudge|f=s        Fudge factor for what clef voices end up in.
  key=s            Lilypond key, such as '\\key c \\minor' or whatever.
  max-leap=s       Largest semitone leap a non-root voice can make (5).
  max-root-leap=s  Largest semitone leap the root can make (7).
  param|p=s        Custom voicing parameters, see Music::Chord::Positions.
  ties             Generate ties between shared pitches.
  transpose=s      Value in semitones to transpose output by.

END_USAGE
}

END {
  unless ( close(STDOUT) ) {
    warn "error: problem closing STDOUT: $!\n";
    exit 74;
  }
}
