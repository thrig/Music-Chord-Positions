#!/usr/bin/perl
#
# Generate combinations of different chord voicings between two
# different scale degrees. (Using 'no_partial_closed' parameter to
# prevent awkward 3rds in middle of otherwise open chord.)
#
# TODO options to control voice leadings (nix || 5ths or whatnot, avoid
# case where one voice falls to pitch occupied by prior voice, etc), auto-
# tie if voice does not change between chords. Also, support
# progressions longer than just two.

use strict;
use warnings;

use File::Basename qw/basename/;
use Getopt::Long qw/GetOptions/;
use List::Util qw/sum/;
use Music::Chord::Positions qw/:all/;
use POSIX qw/floor/;

my (
  @orig_args,     @progression, %interval_sets,   %params,
  %pitch2note,    %pitch_input, %registers,       $duration,
  $exit_status,   $flats,       $fudge,           $key,
  $leap_root_max, $leap_max,    $ly_lower_voices, $ly_upper_voices,
  $mode,          $transpose,
);
$exit_status = 0;

$leap_max      = 5;
$leap_root_max = 7;
%params        = (
  allow_transpositions => 0,
  no_partial_closed    => 1,
  voice_count          => 4,
);
%interval_sets = (
  '5th-major' => [ chord_pos( [qw/0 4 7/], %params ) ],
  '5th-minor' => [ chord_pos( [qw/0 3 7/], %params ) ],
  '5th-dim'   => [ chord_pos( [qw/0 3 6/], %params ) ],
  '5th-aug'   => [ chord_pos( [qw/0 4 8/], %params ) ],
);
%pitch_input = (
  major => {
    I   => { ps => $interval_sets{'5th-major'}, t => 0 },
    II  => { ps => $interval_sets{'5th-minor'}, t => 2 },
    III => { ps => $interval_sets{'5th-minor'}, t => 4 },
    IV  => { ps => $interval_sets{'5th-major'}, t => 5 },
    V   => { ps => $interval_sets{'5th-major'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-minor'}, t => 9 },
    VII => { ps => $interval_sets{'5th-dim'},   t => 11 },
  },
  minor => {
    I   => { ps => $interval_sets{'5th-minor'}, t => 0 },
    II  => { ps => $interval_sets{'5th-dim'},   t => 2 },
    III => { ps => $interval_sets{'5th-major'}, t => 3 },
    IV  => { ps => $interval_sets{'5th-minor'}, t => 5 },
    V   => { ps => $interval_sets{'5th-minor'}, t => 7 },
    VI  => { ps => $interval_sets{'5th-major'}, t => 8 },
    VII => { ps => $interval_sets{'5th-major'}, t => 10 },
  },
);

%pitch2note =
  qw( 0 c 1 cis 2 d 3 dis 4 e 5 f 6 fis 7 g 8 gis 9 a 10 ais 11 b );
%registers = (
  -3 => ",,,",
  -2 => ",,",
  -1 => ",",
  0  => "",
  1  => "'",
  2  => "''",
  3  => "'''",
  4  => "''''",
  5  => "'''''"
);
$duration        = 2;
$fudge           = 0.1;
$key             = '\\key c \\major';
$ly_lower_voices = $ly_upper_voices = '';
$transpose       = 0;

@orig_args = (
  map { my $s = $_; $s =~ s/\\/\\\\/g; $s =~ s/"/\\"/g; $s } basename($0),
  @ARGV
);
GetOptions(
  'flats'           => \$flats,
  'key=s'           => \$key,
  'mode=s'          => \$mode,
  'max-leap=s'      => \$leap_max,
  'max-root-leap=s' => \$leap_root_max,
  'transpose=s'     => \$transpose,
);
@progression = @ARGV;
die "Usage: $0 --mode=major I III\n"
  if !@progression
    or @progression < 2
    or !defined $mode;

if ($flats) {
  %pitch2note =
    qw( 0 c 1 des 2 d 3 ees 4 e 5 f 6 ges 7 g 8 aes 9 a 10 bes 11 b );
}

# Get voice lines, convert to lilypond format, figure out what staff the
# voices should be in. TODO messy, really should be templated or part of
# the module.
{
  my ( @voices, @uv, @lv );

  for my $ps1 ( @{ $pitch_input{$mode}{ $progression[0] }{'ps'} } ) {
    my @from = map { $_ + $pitch_input{$mode}{ $progression[0] }{'t'} } @$ps1;

    for my $ps2 ( @{ $pitch_input{$mode}{ $progression[1] }{'ps'} } ) {
      my @above =
        map { $_ + $pitch_input{$mode}{ $progression[1] }{'t'} } @$ps2;
      my @below =
        map { $_ - scale_deg() + $pitch_input{$mode}{ $progression[1] }{'t'} }
        @$ps2;

      if ( check_dest( \@from, \@above ) ) {
        push @voices, \@from, \@above;
      }
      if ( check_dest( \@from, \@below ) ) {
        push @voices, \@from, \@below;
      }
    }
  }

  @voices = chords2voices(@voices);

  for my $voice (@voices) {
    my ( @registers, $mean_reg_num );
    for my $pitch (@$voice) {
      $pitch += $transpose if $transpose;
      my $ly_pitch = $pitch2note{ $pitch % scale_deg() };
      my $reg_num  = floor( $pitch / scale_deg() );
      push @registers, $reg_num;

      $pitch = $ly_pitch . $registers{$reg_num};
    }
    my $mean_register = floor( sum(@registers) / @$voice + $fudge );

    my $b;

    $voice->[0] .= $duration;
    if ( $mean_register > 0 ) {
      $b = 0;
      push @uv, join " ",
        map { $_, ( ++$b % @progression == 0 ) ? '\\bar "||"' : () } @$voice;
    } else {
      $b = 0;
      push @lv, join " ",
        map { $_, ( ++$b % @progression == 0 ) ? '\\bar "||"' : () } @$voice;
    }
  }

  if (@uv) {
    $ly_upper_voices = "<< {\n" . join( "\n} \\\\ {\n", @uv ) . "\n} >>\n";
  }
  if (@lv) {
    $ly_lower_voices = "<< {\n" . join( "\n} \\\\ {\n", @lv ) . "\n} >>\n";
  }
}

$exit_status = print <<"END_TMPL";
\\version "2.12.0"

#(define-markup-list-command (paragraph layout props args) (markup-list?)
 (interpret-markup-list layout props
   (make-justified-lines-markup-list (cons (make-hspace-markup 2) args))))

\\header {
  title    = "Progressions for @progression ($mode)"
  subtitle = "Music::Chord::Positions v.$Music::Chord::Positions::VERSION"
}

upper = {
  \\clef treble
  \\tempo 4=144
  $key
  $ly_upper_voices
}

lower = {
  \\clef bass
  $key
  $ly_lower_voices
}

\\markuplines { \\paragraph {
"@orig_args"
} }

\\score {
  \\new PianoStaff <<
    \\new Staff = "upper" \\upper
    \\new Staff = "lower" \\lower
  >>
  \\layout { }
  \\midi { }
}
END_TMPL

END {
  unless ( close(STDOUT) ) {
    warn "error: problem closing STDOUT: $!\n";
    exit 74;
  }
}

exit $exit_status;

########################################################################
#
# SUBROUTINES

sub check_dest {
  my ( $from, $to ) = @_;
  my %seen;

  return 0 if abs( $to->[0] - $from->[0] ) > $leap_root_max;
  for my $vi ( 1 .. $#$from ) {
    return 0 if abs( $to->[$vi] - $from->[$vi] ) > $leap_max;
  }

  my @intervals;
  for my $p ( 1 .. $#$from ) {
    push @intervals, $from->[$p] - $from->[ $p - 1 ];
  }
  for my $p ( 1 .. $#$to ) {
    push @intervals, $to->[$p] - $to->[ $p - 1 ];
  }
  return 0 if $seen{"@intervals"}++;

  return 1;
}
